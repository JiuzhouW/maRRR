V <- S$v
U <- U%*%D
E <- X - tcrossprod(U,V)
se2 <- stats::var(as.vector(E))
B <- tcrossprod(solve(crossprod(Y,Y)), Y) %*% U
Sf <- diag(diag((1/n)*crossprod(U-Y%*%B, U-Y%*%B)))
temp1 <- X%*%V-Y%*%B  ## n*r
temp2 <- X-tcrossprod(Y%*%B, V)  ##n*p
trace1 <- psych::tr(crossprod(temp1,temp1))
trace2 <- psych::tr(crossprod(temp2,temp2))
logl <- (-n/2)*(log(det(Sf+se2*diag(r)))+(p-r)*log(se2))-(0.5/se2)*trace2 -
0.5*psych::tr(crossprod(temp1,temp1)%*%solve(Sf+se2*diag(r))) + (0.5/se2)*trace1
rec <- c(logl)
max_niter = 10^5
convg_thres = 10^(-6)
Ldiff = 1
Pdiff= 1
niter = 0
while ((niter <= max_niter) && (Pdiff > convg_thres)){
## record last iter
logl_old <- logl
se2_old <- se2
Sf_old <- Sf
V_old <- V
B_old <- B
## E step
## some critical values
Sfinv <- solve(Sf)
weight <- solve(diag(r)+se2*Sfinv)    ## r*r
cond_Mean <- (se2*Y%*%B%*%Sfinv + X%*%V) %*% weight ## E(U|X), n*r
cond_var <- Sf %*% (diag(r)-weight)
cond_quad <- n*cond_var + crossprod(cond_Mean,cond_Mean)
## M step
V <- crossprod(X, cond_Mean)%*%solve(cond_quad)
se2 <- (psych::tr(X%*%(t(X)-2*tcrossprod(V, cond_Mean))) + n*psych::tr(crossprod(V,V)%*%cond_var) +
psych::tr(tcrossprod(tcrossprod(cond_Mean,V)%*%V, cond_Mean)))/(n*p)
B <- solve(crossprod(Y,Y)) %*% t(Y) %*% cond_Mean
Sf <- (cond_quad + crossprod(Y%*%B,Y%*%B)- crossprod(Y%*%B,cond_Mean) -
crossprod(cond_Mean, Y%*%B))/n
## S step
newS <- RSpectra::svds(V%*%Sf%*%t(V), r)
newV <- newS$u
newSf <- newS$d
newSf <- diag(newSf)
Sf <- newSf[1:r,1:r,drop = FALSE]
B <- tcrossprod(B,V) %*% newV[,1:r,drop = FALSE]
V <- newV[,1:r,drop = FALSE]
## log likelihood
temp1 <- X%*%V - Y%*%B  ## n*r
temp2 <- X-Y%*%B%*%t(V)  ## n*p
logl <- (-n/2)*(log(det(Sf+se2*diag(r))) + (p-r)*log(se2)) - (0.5/se2)*trace2 -
0.5*psych::tr(crossprod(temp1,temp1)%*%solve(Sf+se2*diag(r))) + (0.5/se2)*trace1
rec1 <- c(rec,logl)
## iteration termination
Ldiff <- logl-logl_old  ## should be positive
Pdiff <- norm(V-V_old, type = "F")^2
niter <- niter+1
}
if (niter<max_niter){
cat("EMS converges at precision",convg_thres, "after", niter, "iterations.")
} else{
cat("EMS NOT converges at precision",convg_thres, "after", niter, "iterations!!!")
}
## re-order V, and correspondingly B and Sf, U (one simple remedy for the improper order of V)
I <- order(timeSeries::colStdevs(X%*%V), decreasing = TRUE)
V <- V[,I,drop=FALSE]
B <- B[,I,drop=FALSE]
Sf <- Sf[I,I,drop=FALSE]
## correct sign of V for identifiability
## also correct B and Sf
signchange <- sign(V[1,])
V <- pracma::bsxfun("*", V, pracma::repmat(signchange,nrow(V),1))
B <- pracma::bsxfun("*", B, pracma::repmat(signchange,nrow(B),1))
Sf <- diag(signchange) %*% Sf %*%diag(signchange)
## output U
Sfinv <- solve(Sf)
weight <- solve(diag(r)+se2*Sfinv)  ## r*r
U <- (se2*Y%*%B%*%Sfinv + X%*%V)%*%weight
}
return(list(U=as.matrix(U), V=as.matrix(V), B=as.matrix(B), Sf=as.matrix(Sf), se2=se2))
}
aRRR_compare = function(rank_B = 1,
rank_S = 5,
signal_pair = c(1,10),
seed = 1){
# data generation
dat = data_gen(seed = seed,
n_sample = c(100),
p_x = 100,
p_y = 10,
R_b_true = rank_B,
R_s_true = rank_S,
correlation = 0,
orth_gen = FALSE,
Sinvolved = TRUE,
# correlates to generation of B
modules_B = list(c(1)),
modules_index_B = list(c(1)),
sd_B = signal_pair[1],
#n_mod_B = length(modules_B),
n_mod_B = 1,
# correlates to generation of S
# by default, make the structure of S same as that of B
# if Sinvolved = FALSE, this follow can be set as arbitrary
modules_S = list(c(1)),
modules_index_S = list(c(1)),
sd_S = signal_pair[2],
n_mod_S = 1)
####### maRRR for one matrix, i.e. aRRR #############
ini_dat = ini_gen(seed = 20230225,
n_sample = c(100),
p_x = 100,
p_y = 10,
R_b = 10,
R_s = 10,
n_mod_B = 1,
n_mod_S = 1,
Binvolved = TRUE,
Sinvolved = TRUE)
# generate best penalties based on detected modules
lambdaSs = lambda_S_gen(p_x=100,
modules_index_S=list(c(1)),
n_sample=c(100))
lambdaBs = lambda_B_gen(B_list = dat[[3]])
tik = Sys.time()
result_ALSUV = ALS_UV(X_tot=dat[[1]],
Y_org_list=dat[[2]],
n_mod_B=1,
B_s_list=ini_dat[[3]],
UB_s_list=ini_dat[[1]],
VB_s_list=ini_dat[[2]],
modules_B=list(c(1)),
n_mod_S=1,
S_s_list=ini_dat[[6]],
U_s_list=ini_dat[[4]],
V_s_list=ini_dat[[5]],
modules_S=list(c(1)),
n_sample=c(100),
lambdaBs,
lambdaSs,
10^(-10),
max_iter=100,
Binvolved=TRUE,
Sinvolved=TRUE,
orth_sol=FALSE,
loss_comp=FALSE)
tok = Sys.time()
t_maRRR = tok-tik
outcomes = t(dat[[1]])
predictors = t(dat[[2]][[1]])
# outcomes_centered = scale(outcomes, center = TRUE, scale = FALSE)
# predictors_centered = scale(predictors, center = TRUE , scale = FALSE)
B = dat[[3]][[1]]
S = dat[[4]][[1]]
# centerize: Z = PX, P = I - 1/n*l*l^t
signal = t(B%*%t(predictors)+S)
rmse_B_maRRR = norm(result_ALSUV[[2]][[1]]-B,"F")^2/norm(B,"F")^2
rmse_S_maRRR = norm(result_ALSUV[[3]][[1]]-S,"F")^2/norm(S,"F")^2
X_maRRR = result_ALSUV[[2]][[1]]%*%dat[[2]][[1]] + result_ALSUV[[3]][[1]]
rmse_X_maRRR = norm(t(X_maRRR) - outcomes, "F")^2/norm(outcomes, "F")^2
rmse_signal_maRRR = norm(t(X_maRRR) - signal, "F")^2/norm(signal, "F")^2
# noises takes around 1/3, since BY, S, E are comparably the same
#norm(outcomes_centered - signal_centered, "F")^2/norm(outcomes_centered, "F")^2
#norm(B%*%t(predictors)+S - t(outcomes), "F")^2/norm(outcomes, "F")^2
############ supSVD ##############
# The package is removed from CRAN
# install.packages("SuperPCA")
# library(SuperPCA)
#install.packages("psych")
#library(psych)
# rank of est should be rank_S + rank_B
tik = Sys.time()
result_supSVD = SupPCA(X=outcomes,Y=predictors,r=rank_B+rank_S)
tok = Sys.time()
t_supSVD = tok - tik
B_supSVD = result_supSVD$V%*%t(result_supSVD$B)
rmse_B_supSVD = norm(B_supSVD - B,"F")^2/norm(B,"F")^2
S_supSVD = result_supSVD$V%*%t(result_supSVD$U) - B_supSVD%*%t(predictors)
rmse_S_supSVD = norm(S_supSVD - S,"F")^2/norm(S,"F")^2
X_supSVD = result_supSVD$U%*%t(result_supSVD$V)
rmse_X_supSVD = norm(X_supSVD - outcomes, "F")^2/norm(outcomes, "F")^2
rmse_signal_supSVD = norm(X_supSVD - signal, "F")^2/norm(signal, "F")^2
################# MRCE ####################
# install.packages("MRCE")
library(MRCE)
# tik = Sys.time()
# lam1.vec=rev(10^seq(from=-2, to=0, by=0.5))
# lam2.vec=rev(10^seq(from=-2, to=0, by=0.5))
# cvfit=mrce(Y=outcomes_centered, X=predictors_centered, lam1.vec=lam1.vec, lam2.vec=lam2.vec, method="cv")
# tok = Sys.time()
# tok-tik
# one hour to run the CV version of MRCE
# example codes for previous
# fit=mrce(Y=outcomes, X=predictors, lam1=10^(-1), lam2=10^(-1), method="single")
# fit
# lam2.mat=1000*(fit$Bhat==0)
# refit=mrce(Y=outcomes_centered, X=predictors_centered, lam2=lam2.mat, method="fixed.omega", omega=fit$omega, tol.in=1e-12)
# refit
# now we pick the best performance one from 25 combinations of penalties
lam1.vec=rev(10^seq(from=-2, to=0, by=0.5))
lam2.vec=rev(10^seq(from=-2, to=0, by=0.5))
lam.df = expand.grid(as.list(lam1.vec), as.list(lam2.vec))
lam.list = lapply(apply(lam.df, 1, identity), unlist)
rmse_B_MRCE_list = c()
tik_MRCE = Sys.time()
for(i in 1:length(lam.list)){
tik = Sys.time()
fit=mrce(Y=outcomes, X=predictors, lam1=lam.list[[i]][1],
lam2=lam.list[[i]][2], method="single",maxit.in=1e2)
rmse_B_MRCE_list[i]=norm(t(fit$Bhat)-B,"F")^2/norm(B,"F")^2
tok = Sys.time()
print(i)
print(tok-tik)
}
tok_MRCE = Sys.time()
t_MRCE = tok_MRCE - tik_MRCE
rmse_B_MRCE = min(rmse_B_MRCE_list)
rmse_B_MRCE_list_100 = rmse_B_MRCE_list
############ two stage least square ##########
tik = Sys.time()
stage1LS = lm(outcomes~predictors)
stage2LS = svd(stage1LS$residuals)
B_twoLS = t(stage1LS$coefficients[2:11,])
S_twoLS = t(stage2LS$u[,1:5]%*%diag(stage2LS$d[1:5])%*%t(stage2LS$v[,1:5]))
tok = Sys.time()
t_twoLS = tok - tik
rmse_B_twoLS = norm(B_twoLS-B,"F")^2/norm(B,"F")^2
rmse_S_twoLS = norm(S_twoLS-S,"F")^2/norm(S,"F")^2
X_twoLS = t(stage1LS$fitted.values) + S_twoLS
rmse_X_twoLS = norm(t(X_twoLS) - outcomes, "F")^2/norm(outcomes, "F")^2
rmse_signal_twoLS = norm(t(X_twoLS) - signal, "F")^2/norm(signal, "F")^2
####### two stage Nuclear Norm reduce-rank regression ########
ini_dat = ini_gen(seed = 20230225,
n_sample = c(100),
p_x = 100,
p_y = 10,
R_b = 10,
R_s = 10,
n_mod_B = 1,
n_mod_S = 1,
Binvolved = TRUE,
Sinvolved = FALSE)
tik = Sys.time()
stage1NN = ALS_UV(X_tot=dat[[1]],
Y_org_list=dat[[2]],
n_mod_B=1,
B_s_list=ini_dat[[3]],
UB_s_list=ini_dat[[1]],
VB_s_list=ini_dat[[2]],
modules_B=list(c(1)),
n_mod_S=1,
S_s_list=ini_dat[[6]],
U_s_list=ini_dat[[4]],
V_s_list=ini_dat[[5]],
modules_S=list(c(1)),
n_sample=c(100),
lambdaBs,
lambdaSs,
10^(-10),
max_iter=100,
Binvolved=TRUE,
Sinvolved=FALSE,
orth_sol=FALSE,
loss_comp=FALSE)
B_twoNN = stage1NN[[2]][[1]]
stage2NN = svd(dat[[1]] - stage1NN[[2]][[1]]%*%dat[[2]][[1]])
tok = Sys.time()
t_twoNN = tok - tik
S_twoNN = stage2NN$u%*%diag(thres(stage2NN$d-lambdaSs))%*%t(stage2NN$v)
rmse_B_twoNN = norm(B_twoNN-B,"F")^2/norm(B,"F")^2
rmse_S_twoNN = norm(S_twoNN-S,"F")^2/norm(S,"F")^2
X_twoNN = B_twoNN%*%t(predictors) + S_twoNN
rmse_X_twoNN = norm(t(X_twoNN) - outcomes, "F")^2/norm(outcomes, "F")^2
rmse_signal_twoNN = norm(t(X_twoNN) - signal, "F")^2/norm(signal, "F")^2
return(c(rank_B,signal_pair[1]/signal_pair[2],rmse_B_maRRR,rmse_S_maRRR,rmse_signal_maRRR,t_maRRR,
rmse_B_supSVD,rmse_S_supSVD,rmse_signal_supSVD,t_supSVD,
#rmse_B_MRCE,t_MRCE,
rmse_B_twoLS,rmse_S_twoLS,rmse_signal_twoLS,t_twoLS,
rmse_B_twoNN,rmse_S_twoNN,rmse_signal_twoNN,t_twoNN))
}
#result = aRRR_compare()
rank_B = 1
rank_S = 5
signal_pair = c(1,10)
seed = 1
dat = data_gen(seed = seed,
n_sample = c(100),
p_x = 100,
p_y = 10,
R_b_true = rank_B,
R_s_true = rank_S,
correlation = 0,
orth_gen = FALSE,
Sinvolved = TRUE,
# correlates to generation of B
modules_B = list(c(1)),
modules_index_B = list(c(1)),
sd_B = signal_pair[1],
#n_mod_B = length(modules_B),
n_mod_B = 1,
# correlates to generation of S
# by default, make the structure of S same as that of B
# if Sinvolved = FALSE, this follow can be set as arbitrary
modules_S = list(c(1)),
modules_index_S = list(c(1)),
sd_S = signal_pair[2],
n_mod_S = 1)
####### maRRR for one matrix, i.e. aRRR #############
ini_dat = ini_gen(seed = 20230225,
n_sample = c(100),
p_x = 100,
p_y = 10,
R_b = 10,
R_s = 10,
n_mod_B = 1,
n_mod_S = 1,
Binvolved = TRUE,
Sinvolved = TRUE)
# generate best penalties based on detected modules
lambdaSs = lambda_S_gen(p_x=100,
modules_index_S=list(c(1)),
n_sample=c(100))
lambdaBs = lambda_B_gen(B_list = dat[[3]])
tik = Sys.time()
result_ALSUV = ALS_UV(X_tot=dat[[1]],
Y_org_list=dat[[2]],
n_mod_B=1,
B_s_list=ini_dat[[3]],
UB_s_list=ini_dat[[1]],
VB_s_list=ini_dat[[2]],
modules_B=list(c(1)),
n_mod_S=1,
S_s_list=ini_dat[[6]],
U_s_list=ini_dat[[4]],
V_s_list=ini_dat[[5]],
modules_S=list(c(1)),
n_sample=c(100),
lambdaBs,
lambdaSs,
10^(-10),
max_iter=100,
Binvolved=TRUE,
Sinvolved=TRUE,
orth_sol=FALSE,
loss_comp=FALSE)
tok = Sys.time()
t_maRRR = tok-tik
outcomes = t(dat[[1]])
predictors = t(dat[[2]][[1]])
# outcomes_centered = scale(outcomes, center = TRUE, scale = FALSE)
# predictors_centered = scale(predictors, center = TRUE , scale = FALSE)
B = dat[[3]][[1]]
S = dat[[4]][[1]]
# centerize: Z = PX, P = I - 1/n*l*l^t
signal = t(B%*%t(predictors)+S)
rmse_B_maRRR = norm(result_ALSUV[[2]][[1]]-B,"F")^2/norm(B,"F")^2
rmse_S_maRRR = norm(result_ALSUV[[3]][[1]]-S,"F")^2/norm(S,"F")^2
X_maRRR = result_ALSUV[[2]][[1]]%*%dat[[2]][[1]] + result_ALSUV[[3]][[1]]
rmse_X_maRRR = norm(t(X_maRRR) - outcomes, "F")^2/norm(outcomes, "F")^2
rmse_signal_maRRR = norm(t(X_maRRR) - signal, "F")^2/norm(signal, "F")^2
# noises takes around 1/3, since BY, S, E are comparably the same
#norm(outcomes_centered - signal_centered, "F")^2/norm(outcomes_centered, "F")^2
#norm(B%*%t(predictors)+S - t(outcomes), "F")^2/norm(outcomes, "F")^2
############ supSVD ##############
# The package is removed from CRAN
# install.packages("SuperPCA")
# library(SuperPCA)
#install.packages("psych")
#library(psych)
# rank of est should be rank_S + rank_B
tik = Sys.time()
result_supSVD = SupPCA(X=outcomes,Y=predictors,r=rank_B+rank_S)
tok = Sys.time()
t_supSVD = tok - tik
B_supSVD = result_supSVD$V%*%t(result_supSVD$B)
rmse_B_supSVD = norm(B_supSVD - B,"F")^2/norm(B,"F")^2
S_supSVD = result_supSVD$V%*%t(result_supSVD$U) - B_supSVD%*%t(predictors)
rmse_S_supSVD = norm(S_supSVD - S,"F")^2/norm(S,"F")^2
X_supSVD = result_supSVD$U%*%t(result_supSVD$V)
rmse_X_supSVD = norm(X_supSVD - outcomes, "F")^2/norm(outcomes, "F")^2
rmse_signal_supSVD = norm(X_supSVD - signal, "F")^2/norm(signal, "F")^2
10^seq(from=-2, to=0, by=0.5)
rev(10^seq(from=-2, to=0, by=0.5))
lam1.vec=c(0.05,0.5)
lam2.vec=c(0.05,0.5)
lam.df = expand.grid(as.list(lam1.vec), as.list(lam2.vec))
lam.list = lapply(apply(lam.df, 1, identity), unlist)
rmse_B_MRCE_list = c()
tik_MRCE = Sys.time()
for(i in 1:length(lam.list)){
tik = Sys.time()
fit=mrce(Y=outcomes, X=predictors, lam1=lam.list[[i]][1],
lam2=lam.list[[i]][2], method="single",silent=FALSE,
maxit.out=1e2, maxit.in=1e2,
cov.tol=0.1, tol.out=1e-6)
rmse_B_MRCE_list[i]=norm(t(fit$Bhat)-B,"F")^2/norm(B,"F")^2
tok = Sys.time()
print(i)
print(tok-tik)
}
tok_MRCE = Sys.time()
t_MRCE = tok_MRCE - tik_MRCE
rmse_B_MRCE = min(rmse_B_MRCE_list)
################# MRCE ####################
# install.packages("MRCE")
library(MRCE)
lam1.vec=c(0.05,0.5)
lam2.vec=c(0.05,0.5)
lam.df = expand.grid(as.list(lam1.vec), as.list(lam2.vec))
lam.list = lapply(apply(lam.df, 1, identity), unlist)
rmse_B_MRCE_list = c()
tik_MRCE = Sys.time()
for(i in 1:length(lam.list)){
tik = Sys.time()
fit=mrce(Y=outcomes, X=predictors, lam1=lam.list[[i]][1],
lam2=lam.list[[i]][2], method="single",silent=FALSE)
# maxit.out=1e2, maxit.in=1e2,
# cov.tol=0.1, tol.out=1e-6
rmse_B_MRCE_list[i]=norm(t(fit$Bhat)-B,"F")^2/norm(B,"F")^2
tok = Sys.time()
print(i)
print(tok-tik)
}
tok_MRCE = Sys.time()
t_MRCE = tok_MRCE - tik_MRCE
rmse_B_MRCE = min(rmse_B_MRCE_list)
getwd()
library(devtools)
library(roxygen2)
# setwd("parent_directory")
create("maRRR")
document()
setwd("./maRRR")
document()
setwd("./maRRR")
document()
document()
document()
document()
document()
document()
setwd("..")
getwd()
install("maRRR")
?maRRR
?ALS_UV
setwd("./maRRR")
document()
?lm
document()
document()
setwd("..")
getwd()
install("maRRR")
?ALS_UV
install("maRRR")
library(maRRR)
detach("package:roxygen2", unload = TRUE)
library(roxygen2)
setwd("./maRRR")
document()
setwd("..")
getwd()
install("maRRR")
library(maRRR)
?als
install("maRRR")
setwd("..")
getwd()
setwd("..")
getwd()
setwd("C:\\Users\\wellw\\Desktop\\Prof Lock RA\\marrr")
getwd()
install("maRRR")
library(devtools)
library(roxygen2)
setwd("./maRRR")
document()
setwd("C:\\Users\\wellw\\Desktop\\Prof Lock RA\\marrr")
getwd()
install("maRRR")
library(devtools)
install_github("JiuzhouW/maRRR")
library(maRRR)
dat = data_gen(seed = 20230226,
n_sample = c(100,100),
p_x = 100,
p_y = 10,
R_b_true = 1,
R_s_true = 5,
correlation = 0,
orth_gen = FALSE,
Sinvolved = TRUE,
# correlates to generation of B
modules_B = list(c(1,1),c(1,0),c(0,1)),
modules_index_B = list(c(1,2),c(1),c(2)),
sd_B = c(1,1,1),
#n_mod_B = length(modules_B),
n_mod_B = 3,
# correlates to generation of S
# by default, make the structure of S same as that of B, but free to make them different
# if Sinvolved = FALSE, this follow can be set as arbitrary
modules_S = list(c(1,1),c(1,0),c(0,1)),
modules_index_S = list(c(1,2),c(1),c(2)),
sd_S = c(1,1,1),
n_mod_S = 3)
?data_gen
remove.packages("maRRR")
setwd("C:\\Users\\wellw\\Desktop\\Prof Lock RA\\marrr")
getwd()
setwd("./maRRR")
document()
